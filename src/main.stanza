; Generated by JITX 3.10.0
#use-added-syntax(jitx)
defpackage ethernet-io/main :
  import core
  import jitx
  import jitx/commands
  import jitx/parts

  import ethernet-io/helpers
  import ethernet-io/power
  import ethernet-io/transforms

  import jlc-pcb/stackups/vias

  import jsl
  import power-systems
  import debug/test-points

; Define the shape/size of the board
val board-shape = RoundedRectangle(100.0, 70.0, 0.5)

; Set the Global Query Defaults
set-global-query-defaults!(min-stock = 1, mounting = "smd", case = ["0402", "0603"])

val R-query = ResistorQuery(
  precision = (1 %)
)

val C-query = CapacitorQuery(
  type = "ceramic",
  temperature-coefficient_code = "X7R",
  precision = (10 %)
)

doc: \<DOC>
Reset Circuit

See KSZ9563 Datasheet for more info
@member rail Voltage rail for generating the reset signal
@member reset_n Active low reset signal generated from tactle switch
<DOC>
pcb-module reset-circuit :
  port rail : power
  port reset_n

  inst reset-sw : switches/tactile-sw/device
  inst R : create-resistor(R-query, resistance = 10.0e3)
  inst diode : diodes/SSA33L/component
  inst delay-cap : create-capacitor(
    C-query
    capacitance = 10.0e-6,
    rated-voltage = AtLeast(2.0 * 3.3),
    )

  net (diode.c, R.p[1], rail.V+)
  net (diode.a, R.p[2], reset_n)
  net (reset-sw.p[1], delay-cap.p[1], reset_n)
  net (reset-sw.p[2], delay-cap.p[2], rail.V-)


doc: \<DOC>
EEPROM Configuration for the FTDI interface

This module provides a EEPROM to store the configuration
parameters of the FTDI. This supports the VID, PID, etc.

@member VDD-3v3 Power rail supplying 3.3V - The FTDI needs
3.3V to support it's interface.
@member cfg FTDI specific microwire bus.
<DOC>
pcb-module FTDI-EEPROM :

  port VDD-3v3 : power

  port cfg : microwire-3wire()

  inst ROM : EEPROM/components/MC-93LC46/dev-93LC46C-I
  net (VDD-3v3, ROM.rail-VCC)

  insert-capacitor(
    ROM.C.VCC, ROM.C.VSS,
    C-query
    capacitance = 0.1e-6
    short-trace? = true
  )

  net (ROM.C.CS, cfg.cs)
  net (ROM.C.CLK, cfg.clk)
  net (ROM.C.DI, cfg.do)

  make-test-points(cfg)

  ; Connect a DO -> uwire.data through a 2k resistor
  insert-resistor(
    ROM.C.DO, cfg.do,
    R-query
    resistance = 2.0e3,
  )

  insert-pullup(ROM.C.CS, VDD-3v3)
  insert-pullup(ROM.C.CLK, VDD-3v3)
  insert-pullup(ROM.C.DO, VDD-3v3)
  ; ORG => 1
  ;   Causes the EEPROM to use a 16-bit word.
  insert-pullup(ROM.C.ORG, VDD-3v3)


doc: \<DOC>

<DOC>
pcb-module shield-term-t :
  port SHIELD
  port GND
  insert-resistor(SHIELD, GND, R-query, resistance = 0.0, precision = (1 %))
  insert-capacitor(SHIELD, GND, C-query, capacitance = 4.7e-9, rated-voltage = AtLeast(50.0))

pcb-module usb-interface (USB2-RS:DifferentialRoutingStructure):
  port USB : usb-data
  port VDD-USB : power

  inst USBC : connectors/components/USB/USBTypeC/device

  net VUSB (VDD-USB, USBC.conn.vbus)

  net GND (VUSB.V-)

  inst zener : diodes/MMSZ4-zener/device(5100)
  apply-power(zener, USBC.conn.vbus)

  ; Two separate pull down resistors per the USB-C
  ;  spec Section 4.5.1.2.1
  ; https://www.usb.org/sites/default/files/USB%20Type-C%20Spec%20R2.0%20-%20August%202019.pdf
  val pu-R = create-resistor(resistance = 5.1e3, precision = (1 %))
  for i in indices(USBC.conn.bus.cc) do:
    insert-pulldown(USBC.conn.bus.cc[i], GND, elem-type = pu-R)

  ; This is the USB power connection that we will be used
  ;  for debug power

  make-test-points(VUSB.V+)

  inst esd-prot : diodes/ESD224DQAR/device
  net (esd-prot.GND[1], esd-prot.GND[2], GND)

  val cst = USB-Constraint(proto = USB2, route-struct = USB2-RS)
  within [src, dst] = constrain-topology(USB.data => USBC.conn.bus.data, cst):
    require esd-pair:dual-pair from esd-prot
    topo-pair(src => esd-pair.A => esd-pair.B => dst)

  ; Shield Termination
  inst shield-term : shield-term-t
  net (shield-term.SHIELD, USBC.conn.shield)
  net (shield-term.GND, GND)

  ; Add Keepout for the USB interface.
  val pt-pd-map = port-to-pads(USBC.J)
  val pds = for kvp in pt-pd-map seq-cat:
    value(kvp)
  val b = bounds(pds, layer-spec = SolderMask(Top), expand-by = 0.25)
  val KO = KeepoutOverlay(to-Rectangle(b))
  make-keepout-overlay(
    KO, USBC.J,
    ; TODO - I want to use the stackup to construct the set
    ;  of `Not(LayerIndex(1))` instead of explicitly calling
    ;  out these 3 layers.
    layer-set = [LayerIndex(0), LayerIndex(2), LayerIndex(3)]
    name = "USBC-Keepout"
    )

pcb-module eth-interface :
  port GND

  public inst conns : connectors/components/JD0-0001NL/connector[2]

  for i in 0 to length(conns) do :
    ; RJ45 Shield Terminations
    inst shield-term : shield-term-t
    net (shield-term.SHIELD, conns[i].SHIELD)
    net (shield-term.GND,    GND)

    ; Keepouts for the RJ45 connectors

    ; First we will do a keepout for all layers for the shield and
    ;   mounting holes for the connectors.
    val pds = get-pads-from-ports([conns[i].J.SHIELD, conns[i].J.MOUNT])
    val b = bounds(pds, layer-spec = SolderMask(Top), expand-by = 0.5)
    val KO = KeepoutOverlay(to-Rectangle(b))
    make-keepout-overlay(
      KO, conns[i].J,
      ; TODO Get All Layers here via Introspection
      layer-set = [LayerIndex(0), LayerIndex(1), LayerIndex(2), LayerIndex(3)]
      name = to-string("ETH%_-Shield-Keepout" % [i])
      )

val rmii-bus = rmii(add-rx-error = false)

pcb-module controller :

  port rail-3v3 : power

  port reset-n

  port mii : rmii-bus
  port mdio : miim

  port switch-irq-n
  port switch-pme-n

  port dbg : jtag
  port acm : uart-fc()
  port boot-ctl
  port dbg-active

  public inst ctl : stmicro/components/STM32H723VGT6/proto-circuit(hw-rev = 1)

  net (rail-3v3, ctl.rail-3v3)
  net GND (rail-3v3.V-)

  connect-require-ports(ctl.mcu, [dbg, acm])
  connect-require-ports(ctl.mcu, [reset-n], def-bundle = reset)
  connect-require-ports(ctl.mcu, [switch-pme-n, switch-irq-n, dbg-active])

  net (boot-ctl, ctl.boot-ctl)

  ; setup the RMII interface - we want
  ;  to place resistors on the transmit pins
  ;  from the MCU and short-trace them close
  ;  to the MCU.

  require mii-bus:rmii-bus from ctl.mcu

  topo-bus([mii-bus.crs-dv, mii-bus.ref-clk, mii-bus.rxd] => [mii.crs-dv, mii.ref-clk, mii.rxd])

  ; Create Series resistor
  val series-R-type = create-resistor(resistance = 51.0, precision = (1 %), case = ["0603"])

  val tx-bus = [mii-bus.txd, mii-bus.tx-en]
  val tx-out = [mii.txd, mii.tx-en]
  topo-bus(ShortTrace(tx-bus => series-R-type) => tx-out)

  ; Set signal ends so we get the right routing
  ;    structure all the way to the pin.
  set-signal-end(mii, mii-bus)

  require mng-bus : miim from ctl.mcu

  ; Add Pullup resistors
  net (mng-bus.mdc, mdio.mdc)
  net (mng-bus.mdio, mdio.mdio)

  make-test-points(mng-bus)

  val pullup-miim = create-resistor(resistance = 4.7e3, precision = (1 %))

  inst pullup-mdio : pullup-miim
  net (pullup-mdio.p[1], mng-bus.mdio)
  net (pullup-mdio.p[2], rail-3v3.V+)

  inst pullup-mdc : pullup-miim
  net (pullup-mdc.p[1], mng-bus.mdc)
  net (pullup-mdc.p[2], rail-3v3.V+)

  ; Depopulate the Pullup on MDC because it
  ;  is not needed according to the KSZ9563 datasheet
  ;  This is a hedge.
  instance-status(pullup-mdc):
    bom-status = NotInBOM

public pcb-module comms-core :
  port rail-3v3 : power

  inst PWR : PowerInConn
  inst pwr-mng : power-mng

  net (PWR.V24, pwr-mng.VIN)
  net GND (PWR.V24.V-)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; Gigabit Network Switch
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  inst netsw : microchip-networking/components/KSZ9563/circuit(therm-via = tented-filled-std-via)

  net PWR-3v3 (pwr-mng.VDD-3v3, netsw.VDD-3v3, rail-3v3)
  net PWR-1v2 (pwr-mng.VDD-1v2, netsw.VDD-1v2)

  ; RJ45 Connectors
  inst eth-if : eth-interface
  net (eth-if.GND, GND)

  ; Construct a pool of esd protectors and use pin assignment
  ;  to select from it differential pairs to apply
  ;  to the ethernet MDIs
  val esd = diodes/ESD224DQAR/create-esd-pool(4, GND)
  val mdi-constraint = MDI-1000Base-T-Constraint(
    route-struct = jlc-pcb/stackups/JLC04161H-7628/diff-100()
  )
  for i in 0 to length(eth-if.conns) do:
    require MDI : MDI-1000Base-T from netsw.netsw
    require conn-IF : MDI-1000Base-T from eth-if.conns[i]

    within [src, dst] = constrain-topology(MDI => conn-IF, mdi-constraint):
      require prot-MDI : dual-pair[NUM_PAIRS_1000Base-T] from esd

      topology MDI (src.TP => dst.TP)
      for i in 0 to NUM_PAIRS_1000Base-T do:
        topo-pair(src.TP[i] => prot-MDI[i].A => prot-MDI[i].B  => dst.TP[i])

  ;;  ----  LED Setup ------
  ; The RJ45 connectors have embedded LEDs - so we will use
  ;  drive those LEDs from the netsw component

  ; @TODO - check bias resistor value here -
  ;  compute from characteristics of netsw device IO and
  ;  forward voltage of the LED.

  ; val LED-pts = [netsw.netsw.C.LED1, netsw.netsw.C.LED2]
  for (i in 0 to length(eth-if.conns)) do:
    val led-g = eth-if.conns[i].LED-G
    insert-resistor(rail-3v3.V+, led-g.a, R-query, resistance = 330.0)
    ; net (led-g.c, LED-pt[0])
    net (led-g.c, netsw.LEDs[i][0])

    val led-y = eth-if.conns[i].LED-Y
    insert-resistor(rail-3v3.V+, led-y.a, R-query, resistance = 330.0)
    ; net (led-y.c, LED-pt[1])
    net (led-y.c, netsw.LEDs[i][1])

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; Microcontroller
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  public inst ctl : controller
  net (pwr-mng.VDD-3v3, ctl.rail-3v3)

  val se-50 = jlc-pcb/stackups/JLC04161H-7628/se-50(neckdown = NeckDown(clearance = 0.1))
  val rmii-cst = RMII-Constraint(se-50)
  constrain-topology(ctl.mii => netsw.mii, rmii-cst)

  net MIIM (ctl.mdio, netsw.management)

  net SW_IRQ_N (netsw.irq-n, ctl.switch-irq-n)
  net SW_PME_N (netsw.power-evt-n, ctl.switch-pme-n)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; Reset switch
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  inst reset-circ : reset-circuit
  net (reset-circ.rail, pwr-mng.VDD-3v3)

  net RESET_n (ctl.reset-n, reset-circ.reset_n, netsw.netsw.C.RESET_N)
  make-test-points(RESET_n)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; Debug Interface
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ; USB Interface
  val USB2-RS = jlc-pcb/stackups/JLC04161H-7628/diff-90()
  inst usb-if : usb-interface(USB2-RS)

  ; FTDI Debug Interface

  inst debug-if : FTDI/DebugIF/circuit(
    FTDI/components/FT2232HL/FT2232H-MPSSE,
    FTDI/components/FT2232HL/FT2232H-RS232
    )
  net (debug-if.VDD-3v3, PWR-3v3)
  net (debug-if.VDD-USB, usb-if.VDD-USB, pwr-mng.VUSB-in)

  net (debug-if.USB, usb-if.USB)

  require acm:uart-fc() from debug-if.ftdi
  require dbg:jtag from debug-if.ftdi
  net (acm, ctl.acm)
  net (dbg, ctl.dbg)

  require reset-ctl:gpio from debug-if.ftdi
  net (reset-ctl.gpio, RESET_n)

  require bootloader-en:gpio from debug-if.ftdi
  net BOOT_EN (bootloader-en.gpio, ctl.boot-ctl)
  net DBG_ACTIVE (debug-if.ftdi.C.PWREN_n, ctl.dbg-active)

  inst eeprom : FTDI-EEPROM
  net (eeprom.VDD-3v3, rail-3v3)
  net (eeprom.cfg, debug-if.CFG)


; Module to run as a design
pcb-module top-level :

  inst core : comms-core

  net GND (core.rail-3v3.V-)

  ; Sensors and Control Interfaces Instantiate here.


  ; Board Level Physical Features
  geom(GND):
    copper-pour(LayerIndex(0), isolate = 0.125, rank = 1) = board-shape
    copper-pour(LayerIndex(1), isolate = 0.125, rank = 1) = board-shape


setup-board("ethernet-io", board-shape, signal-shrink = 0.5)
val std-design = top-level $> replace-symbols $> replace-landpatterns
set-main-module(std-design)

; View the results
view-design-explorer()
; view-bom(BOM-STD)
view-schematic()
view-board()

