; Generated by JITX 3.10.0
#use-added-syntax(jitx)
defpackage ethernet-io/main :
  import core
  import jitx
  import jitx/commands
  import jitx/parts

  import ethernet-io/helpers
  import ethernet-io/power
  import ethernet-io/controller
  import ethernet-io/transforms

  import jsl
  import power-systems
  import debug/test-points

; Define the shape/size of the board
val board-shape = RoundedRectangle(100.0, 70.0, 0.5)

; Set the Global Query Defaults
set-global-query-defaults!(min-stock = 1, mounting = "smd", case = ["0402", "0603"])

val R-query = ResistorQuery(
  precision = (1 %)
)

val C-query = CapacitorQuery(
  type = "ceramic",
  temperature-coefficient_code = "X7R",
  precision = (10 %)
)

doc: \<DOC>
EEPROM Configuration for the FTDI interface

This module provides a EEPROM to store the configuration
parameters of the FTDI. This supports the VID, PID, etc.

@member VDD-3v3 Power rail supplying 3.3V - The FTDI needs
3.3V to support it's interface.
@member cfg FTDI specific microwire bus.
<DOC>
pcb-module FTDI-EEPROM :

  port VDD-3v3 : power

  port cfg : microwire-4()

  inst ROM : EEPROM/components/MC-93LC46/dev-93LC46C-I
  net (VDD-3v3, ROM.rail-VCC)

  insert-capacitor(
    ROM.C.VCC, ROM.C.VSS,
    C-query
    capacitance = 0.1e-6
    short-trace? = true
  )

  net (ROM.C.CS, cfg.cs)
  net (ROM.C.CLK, cfg.clk)
  net (ROM.C.DI, cfg.di)
  net (ROM.C.DO, cfg.do)

  ; ORG => 1
  ;   Causes the EEPROM to use a 16-bit word.
  insert-pullup(ROM.C.ORG, VDD-3v3)

doc: \<DOC>
Ethernet Connector's Interface

This module instantiates the connectors and defines the shield
terminations.

@member GND Ground reference for the circuit
<DOC>
pcb-module eth-interface :
  port GND

  public inst conns : connectors/components/JD0-0001NL/connector[2]

  for i in 0 to length(conns) do :
    ; RJ45 Shield Terminations
    inst shield-term : shield-termination(R-query, C-query)
    net (shield-term.SHIELD, conns[i].SHIELD)
    net (shield-term.GND,    GND)

    ; Keepouts for the RJ45 connectors
    val pds = get-pads-from-ports([conns[i].J.SHIELD, conns[i].J.MOUNT])
    val b = bounds(pds, layer-spec = SolderMask(Top), expand-by = 0.5)
    val KO = KeepoutOverlay(to-Rectangle(b))
    make-keepout-overlay(
      KO, conns[i].J,
      layer-set = conductors-by-index(stackup(substrate))
      name = to-string("ETH%_-Shield-Keepout" % [i])
      )

doc: \<DOC>
Communication Core

This module is intended to be a reusable component capable
of providing a gigabit ethernet interface and a microcontroller.

The user can access the microcontroller via the `ctl` public instance
and use pin assignment statements (eg, `require`) to request GPIO or other
peripherals from that microcontroller.

@member rail-3v3 3.3V Power voltage rail that can be used to supply power
to auxilliary circuits.

<DOC>
public pcb-module comms-core :
  port rail-3v3 : power

  inst PWR : PowerInConn
  inst pwr-mng : power-mng

  net (PWR.V24, pwr-mng.VIN)
  net GND (PWR.V24.V-)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; Gigabit Network Switch
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  inst netsw : microchip-networking/components/KSZ9563/circuit(substrate)

  net PWR-3v3 (pwr-mng.VDD-3v3, netsw.VDD-3v3, rail-3v3)
  net PWR-1v2 (pwr-mng.VDD-1v2, netsw.VDD-1v2)

  ; RJ45 Connectors
  inst eth-if : eth-interface
  net (eth-if.GND, GND)

  ; Construct a pool of esd protectors and use pin assignment
  ;  to select from it differential pairs to apply
  ;  to the ethernet MDIs
  val esd = diodes/ESD224DQAR/create-esd-pool(4, GND)
  val mdi-constraint = MDI-1000Base-T-Constraint(
    route-struct = diff-routing-struct(substrate, 100)
  )
  for i in 0 to length(eth-if.conns) do:
    ; We have to use a special bundle type that includes the LEDs
    ;   so the proper LED control pins connected to the right ethernet
    ;   connector.
    val P-bundle = microchip-networking/components/KSZ9563/MDI-1000BaseT-With-LEDs
    require P : P-bundle  from netsw.netsw
    require conn-IF : MDI-1000Base-T from eth-if.conns[i]

    within [src, dst] = constrain-topology(P.MDI => conn-IF, mdi-constraint):
      require prot-MDI : dual-pair[NUM_PAIRS_1000Base-T] from esd

      topology MDI (src.TP => dst.TP)
      for i in 0 to NUM_PAIRS_1000Base-T do:
        topo-pair(src.TP[i] => prot-MDI[i].A => prot-MDI[i].B  => dst.TP[i])

    ; Connect LEDs
    val LED-R = 330.0
    val led-g = eth-if.conns[i].LED-G
    insert-resistor(rail-3v3.V+, led-g.a, R-query, resistance = LED-R)
    net (led-g.c, P.LED[0])

    val led-y = eth-if.conns[i].LED-Y
    insert-resistor(rail-3v3.V+, led-y.a, R-query, resistance = LED-R)
    net (led-y.c, P.LED[1])

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; Microcontroller
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  public inst ctl : controller
  net (pwr-mng.VDD-3v3, ctl.rail-3v3)

  val se-50 = se-routing-struct(substrate, 50, neckdown = NeckDown(clearance = 0.1))
  val rmii-cst = RMII-Constraint(se-50)
  constrain-topology(ctl.mii => netsw.mii, rmii-cst)

  net MIIM (ctl.mdio, netsw.management)
  make-test-points(MIIM)

  net SW_IRQ_N (netsw.irq-n, ctl.switch-irq-n)
  net SW_PME_N (netsw.power-evt-n, ctl.switch-pme-n)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; Reset switch
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  inst reset-circ : debug/circuits/ResetSwitch/reset-circuit(
    delay = 10.0e-3
    R-query = R-query,
    C-query = C-query
    )
  net (reset-circ.rail, pwr-mng.VDD-3v3)

  net RESET_n (ctl.reset-n, reset-circ.reset-n, netsw.netsw.C.RESET_N)
  make-test-points(RESET_n)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; Debug Interface
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ; USB Interface
  inst usb-if : connectors/components/USB/USBTypeC/USBC-HighSpeed-Iface(R-query, C-query)

  ; Add a zener diode across the USB power
  inst zener : diodes/MMSZ4-zener/device(5100)
  apply-power(zener, usb-if.VDD-USB)

  val USB2-RS = diff-routing-struct(substrate, 90)
  val cst = USB-Constraint(proto = USB2, route-struct = USB2-RS)
  constrain-topology(ctl.USB.data => usb-if.USB.data, cst)

  net (ctl.VDD-USB, usb-if.VDD-USB, pwr-mng.VUSB-in)
  make-test-points(usb-if.VDD-USB.V+)

  ; Add Keepout for the USB interface.
  val pt-pd-map = port-to-pads(usb-if.USBC.J)
  val pds = for kvp in pt-pd-map seq-cat:
    value(kvp)
  val b = bounds(pds, layer-spec = SolderMask(Top), expand-by = 0.25)
  val KO = KeepoutOverlay(to-Rectangle(b))
  val USB-KO-layers =
  make-keepout-overlay(
    KO, usb-if.USBC.J,
    ; I'm creating a keepout for all layers except the ground
    ;  plane on `Top + 1`
    layer-set = conductors-by-index(stackup(substrate), omits = [Top + 1])
    name = "USBC-Keepout"
    )

  ; FTDI Configuration
  inst eeprom : FTDI-EEPROM
  net (eeprom.VDD-3v3, rail-3v3)
  net CFG (eeprom.cfg, ctl.debug-if.CFG)

  make-test-points(CFG)


; Module to run as a design
pcb-module top-level :

  inst core : comms-core

  net GND (core.rail-3v3.V-)

  ; Sensors and Control Interfaces Instantiate here.

  ; Board Level Physical Features
  geom(GND):
    copper-pour(LayerIndex(0), isolate = 0.125, rank = 1) = board-shape
    copper-pour(LayerIndex(1), isolate = 0.125, rank = 1) = board-shape


setup-board("ethernet-io", board-shape, signal-shrink = 0.5)
val std-design = top-level $> replace-symbols $> replace-landpatterns
set-main-module(std-design)

; View the results
view-design-explorer()
; view-bom(BOM-STD)
view-schematic()
view-board()

