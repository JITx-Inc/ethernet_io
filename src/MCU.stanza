#use-added-syntax(jitx)
defpackage ethernet-io/MCU:
  import core
  import jitx
  import jitx/commands
  import jitx/parts/query-api

  import jsl/protocols/ethernet/MII/RMII
  import jsl/protocols/ethernet/MII/MIIM

  import jsl/si
  import jsl/pin-assignment
  import jsl/bundles

  import jsl/circuits/CrystalResonator
  import power-systems



val rmii-bus = rmii(add-rx-error = false)


public pcb-module circuit:

  port rail-3v3 : power

  port reset-n

  port mii : rmii-bus
  port mdio : miim

  port switch-irq-n
  port switch-pme-n

  port dbg : jtag
  port acm : uart-fc()
  port boot-ctl


  public inst mcu : stmicro/components/STM32H723VGT6/module

  net (rail-3v3, mcu.rail-VDD)
  net GND (rail-3v3.V-)

  connect-require-ports(mcu, [dbg, acm, reset-n], def-bundle = reset)
  connect-require-ports(mcu, [switch-pme-n, switch-irq-n, dbg-active])

  ; setup the RMII interface - we want
  ;  to place resistors on the transmit pins
  ;  from the MCU and short-trace them close
  ;  to the MCU.

  require mii-bus:rmii-bus from mcu

  topo-bus([mii-bus.crs-dv, mii-bus.ref-clk, mii-bus.rxd] => [mii.crs-dv, mii.ref-clk, mii.rxd])

  ; Create Series resistor
  val series-R-type = create-resistor(resistance = 51.0, precision = (1 %), case = ["0603"])

  val tx-bus = [mii-bus.txd, mii-bus.tx-en]
  val tx-out = [mii.txd, mii.tx-en]
  topo-bus(ShortTrace(tx-bus => series-R-type) => tx-out)

  ; Set signal ends so we get the right routing
  ;    structure all the way to the pin.
  set-signal-end(mii, mii-bus)

  require mng-bus : miim from mcu

  ; Add Pullup resistors
  net (mng-bus.mdc, mdio.mdc)
  net (mng-bus.mdio, mdio.mdio)

  val pullup-miim = create-resistor(resistance = 4.7e3, precision = (1 %))

  inst pullup-mdio : pullup-miim
  net (pullup-mdio.p[1], mng-bus.mdio)
  net (pullup-mdio.p[2], rail-3v3.V+)

  inst pullup-mdc : pullup-miim
  net (pullup-mdc.p[1], mng-bus.mdc)
  net (pullup-mdc.p[2], rail-3v3.V+)

  ; Depopulate the Pullup on MDC because it
  ;  is not needed according to the KSZ9563 datasheet
  ;  This is a hedge.
  instance-status(pullup-mdc):
    bom-status = NotInBOM

  ; Analog Interface

  val ferrite = ethernet_io_lib/components/ferrite/BLM18KG(220)
  inst filt-3v3 : unbalanced-filter(ferrite)
  net (rail-3v3, filt-3v3.vin)
  net (filt-3v3.vout, mcu.rail-VDDA)

  ;; ---- Crystal ----
  ;  12MHz +/- 50ppm

  val xtal-type = ethernet_io_lib/components/crystal/FA-238(12)

  val resonator-type = create-crystal-resonator(
    xtal-type = xtal-type,
    C-load = typ(property(xtal-type.C-load))
    ; From Datasheet Section 6.36.16, Table 51, Page 149
    C-stray = typ(5.0e-12),
    V-rating = 2.0 * 3.3 ; AVDDH
  )

  inst resonator : resonator-type
  net (resonator.COMMON, GND)

  require OSC:stmicro/bundles/high-freq-oscillator from mcu

  net (resonator.p[1], OSC.out)
  ; Add a series resistor for dampening if needed.
  insert-resistor(
    resonator.p[2], OSC.in,
    resistance = 0.0,
    precision = (1 %)
  )


  ; BOOT0 - causes the microcontroller to enter bootloader
  ;   mode on reset

  ; Add a jumnper so that we can control this from USB but we can also
  ;  disable it by removing the resistor if we are having trouble.
  insert-resistor(boot-ctl, mcu.BOOT, resistance = 0.0, precision = (1 %))

  ; This switch allows us to manually force the bootloader sequence
  ; on the microcontroller in the case we are not using the microcontroller.
  inst boot-sw : ethernet_io_lib/components/tactile-sw/device
  net (boot-sw.p[1], rail-3v3.V+)
  net (boot-sw.p[2], mcu.BOOT)
