#use-added-syntax(jitx)
defpackage ethernet-io/network-switch:
  import core
  import jitx
  import jitx/commands
  import jitx/parts/query-api

  import jsl/bundles
  import jsl/si
  import jsl/circuits/ConfigStrap
  import jsl/pin-assignment
  import jsl/design/introspection

  ; import jsl/landpatterns/thermal-vias
  import jsl/landpatterns/framework

  import jsl/protocols/ethernet/MDI/MDI-1000Base-T
  import jsl/protocols/ethernet/MII/RMII
  import jsl/protocols/ethernet/MII/MIIM

  import jsl/circuits/CrystalResonator
  import power-systems/filters

val rmii-bus = rmii(add-rx-error = false)


public pcb-module circuit (therm-via:Via):
  port VDD-1v2 : power
  port VDD-3v3 : power
  port mii : rmii-bus
  port management : miim

  public inst netsw : ethernet_io_lib/components/KSZ9563/module

  net (VDD-3v3, netsw.rail-IO)
  net (VDD-1v2, netsw.rail-1v2)
  net GND (VDD-3v3.V-, netsw.C.PAD)

  ; val tv-g = GridThermalVias(
  ;   via-def = therm-via,
  ;   grid-def = GridPlanner(
  ;     pitch = 1.2,
  ;     columns = 6,
  ;     rows = 6
  ;   )
  ; )

  ; make-via-grid(tv-g, netsw.C.PAD)

  ;; ---- Power ----

  ; Construct a Filter with a ferrite to apply:
  ; 1.  3.3V rail to analog vdd
  ; 2.  1.2V rail to analog core vdd

  val ferrite = ethernet_io_lib/components/ferrite/BLM18KG(220)
  inst filt-3v3 : unbalanced-filter(ferrite)
  net (VDD-3v3, filt-3v3.vin)
  net (filt-3v3.vout, netsw.rail-analog)

  inst filt-1v2 : unbalanced-filter(ferrite)
  net (VDD-1v2, filt-1v2.vin)
  net (filt-1v2.vout, netsw.rail-analog-1v2)


  ;; ---- Crystal ----
  ;  25MHz +/- 50ppm

  val xtal-type = ethernet_io_lib/components/crystal/FA-238(25)

  val resonator-type = create-crystal-resonator(
    xtal-type = xtal-type,
    C-load = typ(property(xtal-type.C-load))
    ; From IBIS file
    C-stray = typ(0.25e-12),
    V-rating = 2.0 * 3.3 ; AVDDH
  )

  inst resonator : resonator-type

  net (resonator.p[1], netsw.C.XI)
  ; Add a series resistor for dampening if needed.
  inst R-xtal-series : create-resistor(resistance = 0.0, precision = (1 %))
  net (resonator.p[2], R-xtal-series.p[1])
  net (R-xtal-series.p[2], netsw.C.XO)
  short-trace(R-xtal-series.p[2], netsw.C.XO)


  ;; ---- Configuration Straps ------

  val pullup-R = create-resistor(resistance = 100.0e3, precision = (1 %))
  inst configs : ConfigStrap(
    num-elems = 4,
    comp = pullup-R,
    pack? = One(LongitudinalPacking(margin = 0.2))
  )
  net (configs.lo, GND)

  require straps:config-strap-bus(4) from configs

  net (straps.config[0], netsw.C.LED0[0])
  net (straps.config[1], netsw.C.LED0[1])
  net (straps.config[2], netsw.C.LED1[0])
  net (straps.config[3], netsw.C.LED1[1])

  ; TODO - RXD1 / RXD0 pull-low to use MIIM bus.

  ;; ---- RJ45 Connectors ------

  inst eth-conn : connectors/components/JD0-0001NL/connector[2]

  ; Construct a pool of esd protectors and use pin assignment
  ;  to select from it differential pairs to apply
  ;  to the ethernet MDIs
  val esd-tmp = CircuitTemplate(
    ethernet_io_lib/components/ESD224DQAR/device, [
    BundleStack(dual-pair, 2),
    BundleStack(pass-through, 4)
  ], name = "esd")

  val pool-type = create-circuit-pool(esd-tmp, 4)
  inst esd : pool-type

  for i in 0 to length(esd.pool-esd) do:
    for j in indices(esd.pool-esd[i].GND) do:
      net (GND, esd.pool-esd[i].GND[j])

  val mdi-constraint = MDI-1000Base-T-Constraint(
    route-struct = jlc-pcb/stackups/JLC04161H-7628/diff-100()
  )
  for i in 0 to length(eth-conn) do:
    require MDI : MDI-1000Base-T from netsw
    require conn-IF : MDI-1000Base-T from eth-conn[i]

    within [src, dst] = constrain-topology(MDI => conn-IF, mdi-constraint):
      require prot-MDI : dual-pair[NUM_PAIRS_1000Base-T] from esd

      for i in 0 to NUM_PAIRS_1000Base-T do:
        topo-pair(src.TP[i] => prot-MDI[i].A => prot-MDI[i].B  => dst.TP[i])


  ;;  ----  LED Setup ------
  ; The RJ45 connectors have embedded LEDs - so we will use
  ;  drive those LEDs from the netsw component

  ; @TODO - check bias resistor value here -
  ;  compute from characteristics of netsw device IO and
  ;  forward voltage of the LED.
  val led-R-type = create-resistor(resistance = 330.0, precision = (1 %))

  for i in 0 to length(eth-conn) do:

    inst g-R : led-R-type
    val led-g = eth-conn[i].LED-G
    net (g-R.p[1], VDD-3v3.V+)
    net (g-R.p[2], led-g.a)
    net (led-g.c, netsw.C.LED0[i])

    inst y-R : led-R-type
    val led-y = eth-conn[i].LED-Y
    net (y-R.p[1], VDD-3v3.V+)
    net (y-R.p[2], led-y.a)
    net (led-y.c, netsw.C.LED0[i])

  ;;  ----  RMII Setup ------
  ; The following
  require sw-bus : rmii-bus from netsw

  ; This inserts series resistors between the
  ;  RMII transmit pins from the netsw and then
  ;  assigns short-trace to them so that they get
  ;  placed near the network switch.

  ; These signals are inputs and do not require the
  ;   series resistor - The MAC side on the microcontroller
  ;   will provide dampening resistors near its transmitter.
  topo-net(sw-bus.tx-en, mii.tx-en)
  for i in 0 to length(sw-bus.txd) do:
    topo-net(sw-bus.txd[i], mii.txd[i])

  val series-R-type = create-resistor(resistance = 51.0, precision = (1 %), case = ["0603"])

  for i in 0 to length(sw-bus.rxd) do:
    inst dampener : series-R-type
    topo-net(sw-bus.rxd[i] => dampener.p[1])
    topo-net(dampener.p[2] => mii.rxd[i])
    short-trace(sw-bus.rxd[i], dampener.p[1])
    pin-model(dampener.p[1], dampener.p[2]) = PinModel(typ(1.0e-12), typ(0.0))

  inst dv-damp : series-R-type
  topo-net(sw-bus.crs-dv => dv-damp.p[1])
  topo-net(dv-damp.p[2] => mii.crs-dv)
  short-trace(sw-bus.crs-dv, dv-damp.p[1])
  pin-model(dv-damp.p[1], dv-damp.p[2]) = PinModel(typ(1.0e-12), typ(0.0))

  ; Clock Mode - this means that
  ;   the `KSZ9563` is generating the clock
  ;   to drive the MAC on the microcontroller
  inst clk-damp : series-R-type
  topo-net(sw-bus.ref-clk => clk-damp.p[1])
  topo-net(clk-damp.p[2] => mii.ref-clk)
  short-trace(sw-bus.ref-clk, clk-damp.p[1])
  pin-model(clk-damp.p[1], clk-damp.p[2]) = PinModel(typ(1.0e-12), typ(0.0))

  ; We need to set signal ends here because the series
  ;  resistors will present a problem when attempting to
  ;  apply the routing structure at the top-level.
  set-signal-end(mii, sw-bus)

  ;;  ---- Management Interface -----

  require miim-bus:miim from netsw
  net (management, miim-bus)



